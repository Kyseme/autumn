### 线程和进程的关系

一个进程包含多个线程,进程的内存空间是共享的.

一个比喻
工厂：CPU承担所有的计算任务.如工厂，时刻在运行.
车间：任意时刻，CPU总是运行一个进程，其他进程处于非运行状态
工人：一个车间，很多工人协作完成一个任务，且车间的空间是工人共享的.一个进程
    可以包含多个线程，进程的内存空间是共享的.
                         车间(进程)
                        /
                工厂(CPU)
                        \
                          工人(线程)
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位.

优缺点：线程执行开销小，但不利于资源的管理和保护，而进程正相反.线程适合于在SMP机器上运行，而进程可以跨机器迁移。

### tcp连接为什么要三次握手，两次握手可以吗？

链接：https://www.zhihu.com/question/24853633/answer/63668444

![alt](https://raw.githubusercontent.com/Kyseme/MarkdownPhoto/master/res/tcp-three.png)

在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。这两种不用的表述其实阐明的是同一个问题。谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。

**第一次握手**

客户端向服务端发送连接请求报文段。该报文段头部中SYN=1，ACK=0,seq=x.请求发送后，客户端便进入SYN-SENT状态
- SYN = 1,ACK = 0表示改报文段为连接请求报文
- x为本次TCP通信的字节流的初始序号

**第二次握手**

服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=1,ACK=1,seq=y,ack=x+1,该应答发送完成后便进入SYN-RCVD状态
- SYN=1,ACK=1表示该报文段为连接同意的应答报文
- seq=y表示服务端作为发送者时，发送字节流的初始序号
- ack=x+1表示服务端希望下一个数据报发送序号从x+1开始的字节

**第三次握手**

客服端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务器发老的连接同意应答已经成功收到，该报文段的头部时ACK=1,seq=x+1,ack=y+1,客户端发完这个报文段之后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时的连接建立完成

为什么建立需要三次握手，而不是两次握手？