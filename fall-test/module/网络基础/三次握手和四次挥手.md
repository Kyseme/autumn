

### tcp连接为什么要三次握手，两次握手可以吗？

链接：https://www.zhihu.com/question/24853633/answer/63668444

![三次握手](https://raw.githubusercontent.com/Kyseme/MarkdownPhoto/master/res/tcp-three.png)

在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。这两种不用的表述其实阐明的是同一个问题。谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。

**第一次握手**

客户端向服务端发送连接请求报文段。该报文段头部中SYN=1，ACK=0,seq=x.请求发送后，客户端便进入SYN-SENT状态
- SYN = 1,ACK = 0表示改报文段为连接请求报文
- x为本次TCP通信的字节流的初始序号

**第二次握手**

服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=1,ACK=1,seq=y,ack=x+1,该应答发送完成后便进入SYN-RCVD状态
- SYN=1,ACK=1表示该报文段为连接同意的应答报文
- seq=y表示服务端作为发送者时，发送字节流的初始序号
- ack=x+1表示服务端希望下一个数据报发送序号从x+1开始的字节

**第三次握手**

客服端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务器发老的连接同意应答已经成功收到，该报文段的头部时ACK=1,seq=x+1,ack=y+1,客户端发完这个报文段之后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时的连接建立完成

### 为什么建立需要三次握手，而不是两次握手？
防止失效的连接请求报文段被服务器接收，从而产生错误

若建立连接只需要两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答才能进入ESTABLISHED状态，而服务端在收到连接请求就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务器，客户端便超时重发请求，如果服务器正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果哪个失效的连接请求抵达了服务端，由于只有两次握手，服务器收到请求就会进入ESYABSHED状态，等待发送数据或主动发送数据。但此时的客服端早已进入CLOSED状态，服务器将会一直等待下去，这样浪费服务器端连接资源。

### TCP四次挥手

![四次挥手](https://raw.githubusercontent.com/Kyseme/MarkdownPhoto/master/res/tcp-four.png)

**第一次挥手**

若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带主要参数为:FIN=1,seq=u.此时，A将进入FIN-WAIT-1状态
- FIN=1表示该报文段是一个连接释放请求
- seq=u，u-1是A向B发送的最后一个字节的序号

**第二次挥手**

B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入CLOSE-WAIT状态，并向A发送连接释放的应答，其报文头包含ACK=1,seq=v,ack=u+1.
- ACK=1除了TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都为1，表示应答
- seq=v,v-1是B向A发送的最后一个字节的序号
- ack=u+1表示服务端希望下一个数据报发送序号从u+1字节开始的报文段，并且已经成功接收前u个字节
A接收该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求

第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据。但是B到A方向的连接仍然存在，B可以继续向A发送数据

**第三次挥手**

当B想A发完所有数据后，向A发送连接释放请求，请求头：FIN=1,ACK=1,seq=w,ack=u+1.B进入LAST-ACK状态

**第四次挥手**

A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。

> 为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？ 

为了保证B能收到A的确认应答。 若A发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，B等待超时后就会重新发送连接释放请求，但此时A已经关闭了，不会作出任何响应，因此B永远无法正常关闭。
